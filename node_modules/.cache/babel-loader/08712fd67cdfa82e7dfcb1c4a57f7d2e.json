{"ast":null,"code":"import React, { Component, Fragment } from 'react';\nimport { createPortal } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport withContentRect from 'react-measure/lib/with-content-rect';\nimport _debounce from 'lodash.debounce';\nimport windowDimensions from 'react-window-dimensions';\nimport invariant from 'invariant';\nimport EventListener from 'react-event-listener';\n/*\n * Taken from draft-js/lib/getVisibleSelectionRect\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\nvar isChrome = /chrome/gi.test(window.navigator.userAgent); // In Chrome, the client rects will include the entire bounds of all nodes that\n// begin (have a start tag) within the selection, even if the selection does\n// not overlap the entire node. To resolve this, we split the range at each\n// start tag and join the client rects together.\n// https://code.google.com/p/chromium/issues/detail?id=324437\n\n/* eslint-disable consistent-return */\n\nfunction getRangeClientRectsChrome(range) {\n  var tempRange = range.cloneRange();\n  var clientRects = [];\n\n  for (var ancestor = range.endContainer; ancestor != null; ancestor = ancestor.parentNode) {\n    // If we've climbed up to the common ancestor, we can now use the\n    // original start point and stop climbing the tree.\n    var atCommonAncestor = ancestor === range.commonAncestorContainer;\n\n    if (atCommonAncestor) {\n      tempRange.setStart(range.startContainer, range.startOffset);\n    } else {\n      tempRange.setStart(tempRange.endContainer, 0);\n    }\n\n    var rects = Array.from(tempRange.getClientRects());\n    clientRects.push(rects);\n\n    if (atCommonAncestor) {\n      var _ref;\n\n      clientRects.reverse();\n      return (_ref = []).concat.apply(_ref, clientRects);\n    }\n\n    tempRange.setEndBefore(ancestor);\n  }\n\n  invariant(false, \"Found an unexpected detached subtree when getting range client rects.\");\n}\n/**\n * Like range.getClientRects() but normalizes for browser bugs.\n */\n\n\nvar getRangeClientRects = isChrome ? getRangeClientRectsChrome : function (range) {\n  return Array.from(range.getClientRects());\n};\n/**\n * Like range.getBoundingClientRect() but normalizes for browser bugs.\n */\n\nfunction getRangeBoundingClientRect(range) {\n  // \"Return a DOMRect object describing the smallest rectangle that includes\n  // the first rectangle in list and all of the remaining rectangles of which\n  // the height or width is not zero.\"\n  // http://www.w3.org/TR/cssom-view/#dom-range-getboundingclientrect\n  var rects = getRangeClientRects(range);\n  var top = 0;\n  var right = 0;\n  var bottom = 0;\n  var left = 0;\n\n  if (rects.length) {\n    // If the first rectangle has 0 width, we use the second, this is needed\n    // because Chrome renders a 0 width rectangle when the selection contains\n    // a line break.\n    if (rects.length > 1 && rects[0].width === 0) {\n      var _rects$ = rects[1];\n      top = _rects$.top;\n      right = _rects$.right;\n      bottom = _rects$.bottom;\n      left = _rects$.left;\n    } else {\n      var _rects$2 = rects[0];\n      top = _rects$2.top;\n      right = _rects$2.right;\n      bottom = _rects$2.bottom;\n      left = _rects$2.left;\n    }\n\n    for (var ii = 1; ii < rects.length; ii++) {\n      var rect = rects[ii];\n\n      if (rect.height !== 0 && rect.width !== 0) {\n        top = Math.min(top, rect.top);\n        right = Math.max(right, rect.right);\n        bottom = Math.max(bottom, rect.bottom);\n        left = Math.min(left, rect.left);\n      }\n    }\n  }\n\n  return {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left,\n    width: right - left,\n    height: bottom - top\n  };\n}\n/**\n * Return the bounding ClientRect for the visible DOM selection, if any.\n * In cases where there are no selected ranges or the bounding rect is\n * temporarily invalid, return null.\n */\n\n\nfunction getVisibleSelectionRect(global) {\n  var selection = global.getSelection();\n\n  if (!selection.rangeCount) {\n    return null;\n  }\n\n  var range = selection.getRangeAt(0);\n  var boundingRect = getRangeBoundingClientRect(range);\n  var top = boundingRect.top,\n      right = boundingRect.right,\n      bottom = boundingRect.bottom,\n      left = boundingRect.left; // When a re-render leads to a node being removed, the DOM selection will\n  // temporarily be placed on an ancestor node, which leads to an invalid\n  // bounding rect. Discard this state.\n\n  if (top === 0 && right === 0 && bottom === 0 && left === 0) {\n    return null;\n  }\n\n  return boundingRect;\n}\n\nvar centerAboveOrBelow = function centerAboveOrBelow(_ref) {\n  var gap = _ref.gap,\n      frameWidth = _ref.frameWidth,\n      frameLeft = _ref.frameLeft,\n      frameTop = _ref.frameTop,\n      boxHeight = _ref.boxHeight,\n      boxWidth = _ref.boxWidth,\n      selectionTop = _ref.selectionTop,\n      selectionLeft = _ref.selectionLeft,\n      selectionWidth = _ref.selectionWidth,\n      selectionHeight = _ref.selectionHeight;\n  var style = {\n    position: \"fixed\"\n  };\n  style.left = selectionLeft + selectionWidth / 2 - boxWidth / 2;\n  style.top = selectionTop - boxHeight - gap; // If the popover is placed beyond the left edge of the screen align\n  // with left edge\n\n  if (style.left < frameLeft) {\n    style.left = frameLeft; // if the popover is placed beyond the right edge align with the\n    // right edge of the sceen\n  } else if (style.left + boxWidth > frameWidth) {\n    style.left = frameWidth - boxWidth;\n  } // if the popover is placed above the frame, position below selection instead\n\n\n  if (style.top < frameTop) {\n    style.top = selectionTop + selectionHeight + gap;\n  }\n\n  return style;\n};\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar objectWithoutProperties = function objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar Popover = function (_Component) {\n  inherits(Popover, _Component);\n\n  function Popover() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Popover);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Popover.__proto__ || Object.getPrototypeOf(Popover)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      isPressed: false,\n      selectionPosition: null,\n      isTextSelected: false,\n      isOpen: false\n    }, _this.updatePosition = function () {\n      var browserSelection = document.getSelection();\n      var _this$props = _this.props,\n          onTextSelect = _this$props.onTextSelect,\n          onTextUnselect = _this$props.onTextUnselect;\n      var selectionRef = _this.props.selectionRef && _this.props.selectionRef.current;\n      var selectionPosition = getVisibleSelectionRect(window);\n\n      if (selectionPosition != null && selectionRef != null && browserSelection != null && selectionRef.contains(browserSelection.anchorNode) === true && selectionRef.contains(browserSelection.focusNode) === true) {\n        if (browserSelection.isCollapsed === false) {\n          onTextSelect && onTextSelect();\n\n          _this.setState({\n            isTextSelected: true,\n            isOpen: true\n          });\n        } else {\n          onTextUnselect && onTextUnselect();\n\n          _this.setState({\n            isTextSelected: false,\n            isOpen: false\n          });\n        }\n\n        _this.setState({\n          selectionPosition: selectionPosition\n        });\n      } else if (_this.state.isTextSelected) {\n        onTextUnselect && onTextUnselect();\n\n        _this.setState({\n          isTextSelected: false,\n          isOpen: false\n        });\n      }\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(Popover, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _props = this.props,\n          selectionRef = _props.selectionRef,\n          measureRef = _props.measureRef,\n          gap = _props.gap,\n          scrollRef = _props.scrollRef,\n          placementStrategy = _props.placementStrategy,\n          contentRect = _props.contentRect,\n          windowHeight = _props.windowHeight,\n          windowWidth = _props.windowWidth,\n          children = _props.children,\n          className = _props.className;\n      var selectionPosition = this.state.selectionPosition;\n      var isOpen = typeof this.props.isOpen === \"boolean\" ? this.props.isOpen : this.state.isOpen;\n      var style = {};\n\n      if (selectionPosition !== null && contentRect.bounds.width != null && contentRect.bounds.width !== 0) {\n        /*\n         * This style object only contains info for positioinng\n         * the popover. It's prop, and these are the arguments passed\n         */\n        style = placementStrategy({\n          gap: gap,\n          frameWidth: windowWidth,\n          frameHeight: windowHeight,\n          frameLeft: 0,\n          frameTop: 0,\n          boxWidth: contentRect.bounds.width,\n          boxHeight: contentRect.bounds.height,\n          selectionTop: selectionPosition.top,\n          selectionLeft: selectionPosition.left,\n          selectionWidth: selectionPosition.width,\n          selectionHeight: selectionPosition.height\n        });\n        style.pointerEvents = this.state.mousePressed === true ? \"none\" : \"auto\";\n      }\n      /*\n       * Before you ask, onSelectionChange only works on the document,\n       * otherwise I would just use selectionRef instead and we wouldn't need\n       * three of those event listeners\n       */\n\n\n      return [React.createElement(EventListener, {\n        key: \"update-position\",\n        target: document,\n        onSelectionChange: this.updatePosition\n      }), React.createElement(EventListener, {\n        key: \"on-resize-window\",\n        target: window,\n        onResize: this.updatePosition\n      }), React.createElement(EventListener, {\n        key: \"on-scroll\",\n        target: scrollRef && scrollRef.current ? scrollRef.current : window,\n        onScroll: this.updatePosition\n      }), React.createElement(EventListener, {\n        key: \"on-mouse-up\",\n        target: selectionRef && selectionRef.current ? selectionRef.current : document.body,\n        onMouseUp: function onMouseUp() {\n          return _this2.setState({\n            mousePressed: false\n          });\n        }\n      }), React.createElement(EventListener, {\n        key: \"on-mouse-down\",\n        target: selectionRef && selectionRef.current ? selectionRef.current : document,\n        onMouseDown: function onMouseDown() {\n          return _this2.setState({\n            mousePressed: true\n          });\n        }\n      }), selectionPosition == null || !isOpen || contentRect.bounds.width == 0 ? null : React.createElement(\"div\", {\n        key: \"popup\",\n        className: className,\n        style: style,\n        ref: measureRef\n      }, children)];\n    }\n  }]);\n  return Popover;\n}(Component);\n\nPopover.defaultProps = {\n  selectionRef: {\n    current: document.body\n  },\n  scrollRef: {\n    current: window\n  },\n  placementStrategy: centerAboveOrBelow,\n  gap: 5\n};\n\nvar wrapPortal = function wrapPortal(Comp) {\n  return function (_ref2) {\n    var children = _ref2.children,\n        props = objectWithoutProperties(_ref2, [\"children\"]);\n    return createPortal(React.createElement(Comp, props, React.createElement(Fragment, null, children)), props.containerNode || document.body);\n  };\n};\n\nPopover.propTypes = {\n  containerNode: PropTypes.instanceOf(Element),\n  measure: PropTypes.func.isRequired,\n  selectionRef: PropTypes.shape({\n    current: PropTypes.instanceOf(Element)\n  }),\n  scrollRef: PropTypes.shape({\n    current: PropTypes.oneOfType([PropTypes.instanceOf(Element), PropTypes.instanceOf(window.constructor)])\n  }),\n  children: PropTypes.node.isRequired,\n  onTextSelect: PropTypes.func,\n  onTextUnselect: PropTypes.func,\n  windowWidth: PropTypes.number,\n  windowHeight: PropTypes.number,\n  className: PropTypes.string,\n  placementStrategy: PropTypes.func,\n  measureRef: PropTypes.func.isRequired,\n  contentRect: PropTypes.object.isRequired,\n  gap: PropTypes.number,\n  isOpen: PropTypes.bool\n};\nvar index = wrapPortal(withContentRect(\"bounds\", \"offset\")(windowDimensions({\n  take: function take() {\n    return {\n      windowWidth: window.innerWidth,\n      windowHeight: window.innerHeight\n    };\n  },\n  debounce: function debounce(onResize) {\n    return _debounce(onResize, 120);\n  }\n})(Popover)));\nexport default index;","map":null,"metadata":{},"sourceType":"module"}